program "Airports"

breed Airport (Latitude:float, Longitude:float, Altitude:float, pos:vec4, n:vec4, color:vec4)

patch Place(pos:vec4)
breed Plane (pos:vec4, color:vec4, p0:vec4, p1:vec4, dot:float, omega:float, t:float, step:float, rand:float)

data Airports("airports.dat", "csv")

def setColor() {
  this.color = vec4(this.pos:vec4.xyz / 512.0, 1)
}

def setNormalLocation() {
  var la = this.Latitude:float  // [-90, 90]
  var lo = this.Longitude:float // [-180, 180]
  //var al = this.Altitude;

  la = la * 3.141592653589793 / 180.0  //  [-pi/2, pi/2]
  lo = lo * 3.141592653589793 / 180.0  //  [-pi, pi]

  this.n = vec4(cos(la) * sin(lo), cos(la) * cos(lo), sin(la), 0)
}

def setPlace(place:object) {
  place.pos = this.n:vec4
}

def setLocation() {
  var r = 200;
  this.pos = this.n:vec4 * r + 256
}

def planeColor() {
  this.color = vec4(1, 1, 1, 1)
}

def maybeGoToRandomPlace(n:float, r:float) {
  if (this.t:float < 0) {
    var ind = floor(random(a_index.x * r) * n);
    var x = (mod(ind, 64 * 64)) * 8;
    var y = mod(floor(ind / 64), 64) * 8;
    var z = floor(ind / (64 * 64)) * 8;

    this.pos = vec4(x, y, z, 0)
  }
}

def maybeGoToAPlace() {
  if (this.t:float < 0) {
    this.pos = vec4(10, 1, 1, 0)
  }
}

def maybeGoToARegularPlace() {
  var ax = a_index.x;
  var ay = a_index.y;

  var ind = floor(ay * 1024 + ax);

  var x = mod(ind, 64 * 64) * 8;
  var y = mod(floor(ind / 64), 64) * 8;
  var z = floor(ind / (64 * 64)) * 8;

  this.pos = vec4(x, y, z, 0)
}

def maybeGoToBRegularPlace(n:float) {
  var ax = a_index.x;
  var ay = a_index.y;

  var ind = ay * 1024 + ax;

  var x = mod(ind, (64 * 64)) * 8;
  var y = mod(floor(ind / 64), 64) * 8;
  var z = floor(ind / (64 * 64)) * 8;

  this.pos = vec4(63-x, 63-y, z, 0)
}

def loadPlace(place:object, isDest:float) {
  if (this.t:float < 0) {
    var pos = place.pos:vec4;

    if (isDest == 1) {
      this.p1 = pos
    } else {
      this.p0 = pos
    }
  }
}

def maybeComputeDist() {
  if (this.t:float < 0) {
    var p0 = this.p0:vec4

    var p1 = this.p1:vec4

    var dot = dot(p0, p1)
    var omega = acos(dot)

    this.dot = dot
    this.omega = omega
    this.step = (3 / 1000.0) / omega
  }
}

def initT() {
  this.t = -1
}

def maybeInitT() {
  if (this.t:float < 0) {
     this.t = 0
  }
}

def incrT() {
  var t = this.t:float
  if (t >= 0) {
    t = t + this.step:float
  }
  if (t > 1.0) {
    t = -1
  }
  this.t = t
}

def move() { // for a Plane.
  var p0 = this.p0:vec4

  var p1 = this.p1:vec4

  var t = this.t:float
  var dot = this.dot:float
  var omega = this.omega:float

  var t1:float = sin((1-t) * omega) / sin(omega)
  var t2:float = sin(t * omega) / sin(omega)

  var p = (t1 * p0) + (t2 * p1)

  var r = 200;

  this.pos = r * p + 256
}

static setup() {
  Airport.loadData(Airports)   // Lat Long <- data
  var count = Airport.count    // number of data
  Airport.setNormalLocation()  // nx, ny, nz <- f(Lat, Long)
  Airport.fillCuboid("pos", vec3(512, 512, 24), 8) // x, y, z, count 
  Airport.setPlace(Place)      // place.x, place.y, place.z <- nx, ny, nz
  Airport.setLocation()        // x, y, z <- nx, ny, nz
  Airport.setCount(count)
  Airport.setColor()

  Plane.setCount(10000)
  Plane.planeColor()
  Plane.initT()

//  Plane.maybeGoToRandomPlace(4000, 2.2);
//  Plane.loadPlace(Place, 0);
//  Plane.maybeGoToRandomPlace(4000, -3.4);
//  Plane.loadPlace(Place, 1);
//  Plane.maybeComputeDist();
//  Plane.maybeInitT();

  loop.start();
}

static loop() {
  Plane.maybeGoToRandomPlace(4000, time)
  Plane.loadPlace(Place, 0)
  Plane.maybeGoToRandomPlace(4000, time + 0.3)
  Plane.loadPlace(Place, 1)
  Plane.maybeComputeDist()
  Plane.maybeInitT()

  Plane.move()
  Plane.incrT()

  Airport.render()
  Plane.render()
}
